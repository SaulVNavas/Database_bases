<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Resaltado en tiempo real</title>
  <style>
    .monaco-editor .name-style {
      color: #1768ff; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .type-style {
      color: #F1FC17 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .struct-style {
      color: #87FF17 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .control-style {
      color: #1797FF !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .operations-style {
      color: #b4a9e7 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .visibility-style {
      color: #FFA500 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .others-style {
      color: #FF1793 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .comment-style {
      color:  #00ac42; /* verde */
      font-weight: bold;
    }
    #editor {
      width: 800px;
      height: 400px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="editor"></div>

  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
  <script>
    require.config({ paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs" } });

    require(["vs/editor/editor.main"], function () {
      const editor = monaco.editor.create(document.getElementById("editor"), {
        value: "Escribe Hola varias veces...\n",
        language: "customVHDL",
        theme: "vs-dark"
      });

      let allDecorations = [];
      const editorModel = editor.getModel();
      let currentPositionStyle;

      function wordSetToRegex (regexSet){
        return new RegExp(`\\b(${regexSet.join('|')})\\b`, "g");
      }

      function wordsInRange(range){
        const words = [];

        for (let line = range.startLineNumber; line <= range.endLineNumber; line++) {
          if(line > editorModel.getLineCount()){
            break;
          }

          const lineContent = editorModel.getLineContent(line);

          // Limitar columnas al rango dado
          const startCol = (line === range.startLineNumber) ? range.startColumn : 1;
          const endCol   = (line === range.endLineNumber) ? range.endColumn : lineContent.length + 1;

          const subLine = lineContent.substring(startCol - 1, endCol - 1);

          let match;
          const regex = /\w+/g;
          while ((match = regex.exec(subLine)) !== null) {
            const word = match[0];
            const startColumn = startCol + match.index;
            const endColumn = startColumn + word.length;

            words.push({
              word,
              range: new monaco.Range(line, startColumn, line, endColumn)
            });
          }
        }

        return words;
      }


      // Expresiones regulares generadas por términos clave
        const highlightTriggers = {
            type: {
                regex: wordSetToRegex(['bit', 'boolean', 'character', 'integer', 'real', 'string', 'time', 'variable']),
                regexStyle: 'type-style'
            },
            struct: {
                regex: wordSetToRegex(['architecture', 'begin', 'block', 'component', 'configuration',
                    'end', 'entity', 'generate', 'package', 'process']),
                regexStyle: 'struct-style'
            },
            control: {
                regex: wordSetToRegex(['if', 'then', 'else', 'elsif', 'case', 'when', 'loop', 'while', 'for', 'next', 'exit']),
                regexStyle: 'control-style'
            },
            operations: {
                regex: wordSetToRegex(['signal', 'variable', 'constant', ':=', '=>', 'and', 'or', 'not', 'xor', 'nand', 'nor', 'xnor']),
                regexStyle: 'operations-style'
            },
            visibility: {
                regex: wordSetToRegex(['library', 'use', 'all', 'is', 'in', 'out', 'inout', 'buffer', 'linkage']),
                regexStyle: 'visibility-style'
            },
            others: {
                regex: wordSetToRegex(['wait', 'assert', 'report', 'severity', 'after', 'transport', 'reject', 'guarded', 'open', 'null']),
                regexStyle: 'others-style'
            }
        };

        editor.onDidChangeModelContent((e) => {
          const model = editor.getModel();
          const affectedWords = new Set();

          e.changes.forEach(change => {
            // 1. Rango completo de líneas afectadas
            const startLine = change.range.startLineNumber;
            const endLine = change.range.endLineNumber;
            
            for (let line = startLine-1; line <= endLine+1; line++) {
              if(line < 1){
                continue;
              }
              if(line > editorModel.getLineCount()){
                break;
              }

              const lineText = model.getLineContent(line);
              const words = lineText.match(/\w+/g) || [];
              words.forEach(w => affectedWords.add(w));
            }

          // 2. Texto insertado (multi-línea)
          const insertedWords = change.text.match(/\w+/g) || [];
          insertedWords.forEach(w => affectedWords.add(w));
        });

        console.log("Todas las palabras afectadas:", Array.from(affectedWords));
      });
    });
  </script>
</body>
</html>
