<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Resaltado en tiempo real</title>
  <style>
    .monaco-editor .name-style {
      color: #1768ff; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .type-style {
      color: #F1FC17 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .struct-style {
      color: #87FF17 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .control-style {
      color: #1797FF !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .operations-style {
      color: #b4a9e7 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .visibility-style {
      color: #FFA500 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .others-style {
      color: #FF1793 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .comment-style {
      color:  #00ac42; /* verde */
      font-weight: bold;
    }
    #editor {
      width: 800px;
      height: 400px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="editor"></div>

  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
  <script>
    require.config({ paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs" } });

    require(["vs/editor/editor.main"], function () {
      const editor = monaco.editor.create(document.getElementById("editor"), {
        value: "Escribe Hola varias veces...\n",
        language: "customVHDL",
        theme: "vs-dark"
      });

      let decorations = [];
      const editorModel = editor.getModel();

      function singleRegexSet (regexSet){
        return new RegExp(`\\b(${regexSet.join('|')})\\b`, 'g');
      }

      // Expresiones regulares generadas por términos clave
      const regexSet = [
        {
          regexString: singleRegexSet(['bit', 'boolean', 'character', 'integer', 'real', 'string', 'time', 'variable']),
          regexStyle: 'type-style'
        },
        {
          regexString: singleRegexSet(['architecture', 'begin', 'block', 'component', 'configuration',
            'end', 'entity', 'generate', 'package', 'process']),
          regexStyle: 'struct-style'
        },
        {
          regexString: singleRegexSet(['if', 'then', 'else', 'elsif', 'case', 'when', 'loop', 'while', 'for', 'next', 'exit']),
          regexStyle: 'control-style'
        },
        {
          regexString: singleRegexSet(['signal', 'variable', 'constant', ':=', '=>', 'and', 'or', 'not', 'xor', 'nand', 'nor', 'xnor']),
          regexStyle: 'operations-style'
        },{
          regexString: singleRegexSet(['library', 'use', 'all', 'is', 'in', 'out', 'inout', 'buffer', 'linkage']),
          regexStyle: 'visibility-style'
        },{
          regexString: singleRegexSet(['wait', 'assert', 'report', 'severity', 'after', 'transport', 'reject', 'guarded', 'open', 'null']),
          regexStyle: 'others-style'
        },
      ];
      
      let nameRegexes = /(bit|boolean|character|integer|real|string|time|variable)\+s(\w+)/gi;

      function highlightWord(){
        let allDecorations = [];
        let nameWords = new Set();

        const regex = /(bit|boolean|character|integer|real|string|time|variable)/i;
        const nameRegexMatches = editorModel.findMatches(regex.source, null, true, true, null, true);

        nameRegexMatches.forEach(nameMatch => {
          const triggerRange = nameMatch.range;
          const nameSearchRange = new monaco.Range(
            triggerRange.endLineNumber,
            triggerRange.endColumn,
            editorModel.getLineCount(),
            editorModel.getLineMaxColumn(editorModel.getLineCount())
          );
          const newNameMatches = editorModel.findMatches(
            "\\w+",   // texto o regex
            nameSearchRange,    // desde dónde empezar la búsqueda
            true,       // isRegex
            true,       // matchCase
            null,        // wordSeparators
            true,         // captureMatches
          );
          if (newNameMatches.length > 0) {
            nameWords.add('\\b' + newNameMatches[0].matches + '\\b');
          }
        });
        console.log(nameWords.size)
        if (nameWords.size == 0){
          decorations = editor.deltaDecorations(decorations, []);
        }
        else {
          nameWords.forEach(nameWord => {
            const nameMatches = editorModel.findMatches(nameWord, true, true, true, null, true);
            const newDecorations = nameMatches.map(match => ({
              range: match.range,
              options: { inlineClassName: "name-style" }
            }));
            allDecorations = allDecorations.concat(newDecorations);
          });
        }

        regexSet.forEach(regex => {
          const matches = editorModel.findMatches(regex.regexString.source, true, true, true, null, true);
          const newDecorations = matches.map(match => ({
            range: match.range,
            options: { inlineClassName: regex.regexStyle }
          }));
          allDecorations = allDecorations.concat(newDecorations);
        });

        allDecorations = editor.deltaDecorations(decorations, allDecorations);
      }

      editor.onDidChangeModelContent(() => {
        highlightWord();
      });
    });
  </script>
</body>
</html>
