<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Resaltado en tiempo real</title>
  <style>
    .monaco-editor .type-style {
      color: #F1FC17 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .struct-style {
      color: #87FF17 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .control-style {
      color: #1797FF !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .operations-style {
      color: #b4a9e7 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .visibility-style {
      color: #FFA500 !important; /* rojo */
      font-weight: bold;
    }
    .monaco-editor .name-style {
      color: #1768ff !important; /* rojo */
    }
    .monaco-editor .others-style {
      color: #FF1793 !important; /* rojo */
      font-weight: bold;
    }
    #editor {
      width: 800px;
      height: 400px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="editor"></div>

  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
  <script>
    require.config({ paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs" } });

    require(["vs/editor/editor.main"], function () {
      const editor = monaco.editor.create(document.getElementById("editor"), {
        value: "Escribe Hola varias veces...\n",
        language: "customVHDL",
        theme: "vs-dark"
      });

      let decorations = [];

      function singleRegexSet (regexSet){
        return new RegExp(`\\b(${regexSet.join('|')})\\b`, 'g');
      }

      // Expresiones regulares generadas por tÃ©rminos clave
      const regexSet = [
        {
          regexString: singleRegexSet(['bit', 'boolean', 'character', 'integer', 'real', 'string', 'time', 'variable']),
          regexStyle: 'type-style'
        },
        {
          regexString: singleRegexSet(['architecture', 'begin', 'block', 'component', 'configuration',
            'end', 'entity', 'generate', 'package', 'process']),
          regexStyle: 'struct-style'
        },
        {
          regexString: singleRegexSet(['if', 'then', 'else', 'elsif', 'case', 'when', 'loop', 'while', 'for', 'next', 'exit']),
          regexStyle: 'control-style'
        },
        {
          regexString: singleRegexSet(['signal', 'variable', 'constant', ':=', '=>', 'and', 'or', 'not', 'xor', 'nand', 'nor', 'xnor']),
          regexStyle: 'operations-style'
        },{
          regexString: singleRegexSet(['library', 'use', 'all', 'is', 'in', 'out', 'inout', 'buffer', 'linkage']),
          regexStyle: 'visibility-style'
        },{
          regexString: singleRegexSet(['wait', 'assert', 'report', 'severity', 'after', 'transport', 'reject', 'guarded', 'open', 'null']),
          regexStyle: 'others-style'
        },
      ];
      
      let nameRegexes = /(bit|boolean|character|integer|real|string|time|variable)\+s(\w+)/gi;

      function highlightWord(){
        let allDecorations = [];
        regexSet.forEach(regex => {
          const matches = editor.getModel().findMatches(regex.regexString.source, true, true, true, null, true);
          const newDecorations = matches.map(match => ({
            range: match.range,
            options: { inlineClassName: regex.regexStyle }
          }));
          allDecorations = allDecorations.concat(newDecorations);
        });

        let nameWords = new Set();

        const regex = /(bit|boolean|character|integer|real|string|time|variable)\s+(\w+)/gi;
        const nameRegexMatches = editor.getModel().findMatches(regex.source, null, true, true, null, true);

        for (const nameRegexMatch of nameRegexMatches) {
          if (nameRegexMatch.matches && nameRegexMatch.matches[2]) {
            nameWords.add('\\b' + nameRegexMatch.matches[2] + '\\b');
          }
        }

        nameWords.forEach(nameWord => {
          const nameMatches = editor.getModel().findMatches(nameWord, null, true, true, null, true);
          nameMatches.forEach(nameMatch => {
            allDecorations.push({
              range: nameMatch.range,
              options: { inlineClassName: "name-style" }
            });
          });
        });

        decorations = editor.deltaDecorations(decorations, allDecorations);
      }

      editor.onDidChangeModelContent(() => {
        highlightWord();
      });
    });
  </script>
</body>
</html>
